/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module led_driver #(
        parameter COLUMN_DIMENSION = 16'h10,
        parameter ROW_DIMENSION = 16'h1,
        parameter PIXEL_COUNT = 16'h8,
        parameter BUFFER_SIZE = 11'h400
    ) (
        input wire clk,
        input wire rst,
        input wire [31:0] led1,
        input wire [31:0] led2,
        input wire [31:0] led3,
        output reg [2:0] data
    );
    logic [31:0] R_175e89a3_index;
    logic [31:0] RR_175e89a3_index;
    localparam logic [3:0][23:0] COLOR_ENCODING1 = {{24'hff00, 24'hff0000, 24'hff00, 24'h0}};
    localparam logic [3:0][23:0] COLOR_ENCODING2 = {{24'hff0000, 24'hff0000, 24'hff00, 24'h0}};
    localparam logic [3:0][23:0] COLOR_ENCODING3 = {{24'hff, 24'hff0000, 24'hff00, 24'h0}};
    localparam ENCODING_AMOUNT = 5'h4;
    logic [(BUFFER_SIZE)-1:0] pixel_address1;
    logic [(BUFFER_SIZE)-1:0] pixel_address2;
    logic [(BUFFER_SIZE)-1:0] pixel_address3;
    logic [1:0] current_pixel_encoding_1;
    logic [1:0] current_pixel_encoding_2;
    logic [1:0] current_pixel_encoding_3;
    localparam CLK_FREQ = 24'h989680;
    localparam _MP_PIXEL_COUNT_1555123572 = PIXEL_COUNT;
    logic M_driver1_update;
    logic [23:0] M_driver1_color;
    logic M_driver1_clear;
    logic [($clog2(_MP_PIXEL_COUNT_1555123572))-1:0] M_driver1_pixel_address;
    logic M_driver1_data;
    logic M_driver1_next_pixel;
    logic M_driver1_reset;
    logic M_driver1_done;
    
    ws2812b_driver #(
        .PIXEL_COUNT(_MP_PIXEL_COUNT_1555123572)
    ) driver1 (
        .rst(rst),
        .clk(clk),
        .update(M_driver1_update),
        .color(M_driver1_color),
        .clear(M_driver1_clear),
        .pixel_address(M_driver1_pixel_address),
        .data(M_driver1_data),
        .next_pixel(M_driver1_next_pixel),
        .reset(M_driver1_reset),
        .done(M_driver1_done)
    );
    
    
    localparam _MP_PIXEL_COUNT_58718500 = PIXEL_COUNT;
    logic M_driver2_update;
    logic [23:0] M_driver2_color;
    logic M_driver2_clear;
    logic [($clog2(_MP_PIXEL_COUNT_58718500))-1:0] M_driver2_pixel_address;
    logic M_driver2_data;
    logic M_driver2_next_pixel;
    logic M_driver2_reset;
    logic M_driver2_done;
    
    ws2812b_driver #(
        .PIXEL_COUNT(_MP_PIXEL_COUNT_58718500)
    ) driver2 (
        .rst(rst),
        .clk(clk),
        .update(M_driver2_update),
        .color(M_driver2_color),
        .clear(M_driver2_clear),
        .pixel_address(M_driver2_pixel_address),
        .data(M_driver2_data),
        .next_pixel(M_driver2_next_pixel),
        .reset(M_driver2_reset),
        .done(M_driver2_done)
    );
    
    
    localparam _MP_PIXEL_COUNT_781402174 = PIXEL_COUNT;
    logic M_driver3_update;
    logic [23:0] M_driver3_color;
    logic M_driver3_clear;
    logic [($clog2(_MP_PIXEL_COUNT_781402174))-1:0] M_driver3_pixel_address;
    logic M_driver3_data;
    logic M_driver3_next_pixel;
    logic M_driver3_reset;
    logic M_driver3_done;
    
    ws2812b_driver #(
        .PIXEL_COUNT(_MP_PIXEL_COUNT_781402174)
    ) driver3 (
        .rst(rst),
        .clk(clk),
        .update(M_driver3_update),
        .color(M_driver3_color),
        .clear(M_driver3_clear),
        .pixel_address(M_driver3_pixel_address),
        .data(M_driver3_data),
        .next_pixel(M_driver3_next_pixel),
        .reset(M_driver3_reset),
        .done(M_driver3_done)
    );
    
    
    logic [(BUFFER_SIZE)-1:0] D_led_encoding_1_d, D_led_encoding_1_q = 2'h2;
    logic [(BUFFER_SIZE)-1:0] D_led_encoding_2_d, D_led_encoding_2_q = 2'h2;
    logic [(BUFFER_SIZE)-1:0] D_led_encoding_3_d, D_led_encoding_3_q = 2'h2;
    always @* begin
        D_led_encoding_1_d = D_led_encoding_1_q;
        D_led_encoding_2_d = D_led_encoding_2_q;
        D_led_encoding_3_d = D_led_encoding_3_q;
        
        data = 1'h0;
        M_driver1_update = 1'h1;
        M_driver2_update = 1'h1;
        M_driver3_update = 1'h1;
        M_driver1_clear = 1'h0;
        M_driver2_clear = 1'h0;
        M_driver3_clear = 1'h0;
        D_led_encoding_1_d = D_led_encoding_1_q;
        D_led_encoding_2_d = D_led_encoding_2_q;
        D_led_encoding_3_d = D_led_encoding_3_q;
        pixel_address1 = M_driver1_pixel_address;
        pixel_address2 = M_driver2_pixel_address;
        pixel_address3 = M_driver3_pixel_address;
        for (RR_175e89a3_index = 0; RR_175e89a3_index < 2'h2; RR_175e89a3_index = RR_175e89a3_index + 1) begin
      R_175e89a3_index = (0) + RR_175e89a3_index * (1);
            current_pixel_encoding_1[R_175e89a3_index] = D_led_encoding_1_q[led1[pixel_address1]];
            current_pixel_encoding_2[R_175e89a3_index] = D_led_encoding_2_q[led2[pixel_address2]];
            current_pixel_encoding_3[R_175e89a3_index] = D_led_encoding_3_q[led3[pixel_address3]];
        end
        M_driver1_color = COLOR_ENCODING1[current_pixel_encoding_1];
        M_driver2_color = COLOR_ENCODING2[current_pixel_encoding_2];
        M_driver3_color = COLOR_ENCODING3[current_pixel_encoding_3];
        data[1'h0] = M_driver1_data;
        data[1'h1] = M_driver2_data;
        data[2'h2] = M_driver3_data;
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_led_encoding_1_q <= 2'h2;
            D_led_encoding_2_q <= 2'h2;
            D_led_encoding_3_q <= 2'h2;
        end else begin
            D_led_encoding_1_q <= D_led_encoding_1_d;
            D_led_encoding_2_q <= D_led_encoding_2_d;
            D_led_encoding_3_q <= D_led_encoding_3_d;
        end
    end
endmodule